{"ast":null,"code":"import _get from \"D:\\\\Projects\\\\ngx-viewer\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\get.js\";\nimport _classCallCheck from \"D:\\\\Projects\\\\ngx-viewer\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Projects\\\\ngx-viewer\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _possibleConstructorReturn from \"D:\\\\Projects\\\\ngx-viewer\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\possibleConstructorReturn.js\";\nimport _isNativeReflectConstruct from \"D:\\\\Projects\\\\ngx-viewer\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\isNativeReflectConstruct.js\";\nimport _getPrototypeOf from \"D:\\\\Projects\\\\ngx-viewer\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\getPrototypeOf.js\";\nimport _inherits from \"D:\\\\Projects\\\\ngx-viewer\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\n\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\n\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n\nimport { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport var VirtualTimeScheduler = /*#__PURE__*/(function () {\n  var VirtualTimeScheduler = /*#__PURE__*/function (_AsyncScheduler) {\n    function VirtualTimeScheduler() {\n      var _this;\n\n      var SchedulerAction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : VirtualAction;\n      var maxFrames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;\n\n      _classCallCheck(this, VirtualTimeScheduler);\n\n      _this = _callSuper(this, VirtualTimeScheduler, [SchedulerAction, function () {\n        return _this.frame;\n      }]);\n      _this.maxFrames = maxFrames;\n      _this.frame = 0;\n      _this.index = -1;\n      return _this;\n    }\n\n    _inherits(VirtualTimeScheduler, _AsyncScheduler);\n\n    return _createClass(VirtualTimeScheduler, [{\n      key: \"flush\",\n      value: function flush() {\n        var actions = this.actions,\n            maxFrames = this.maxFrames;\n        var error, action;\n\n        while ((action = actions[0]) && action.delay <= maxFrames) {\n          actions.shift();\n          this.frame = action.delay;\n\n          if (error = action.execute(action.state, action.delay)) {\n            break;\n          }\n        }\n\n        if (error) {\n          while (action = actions.shift()) {\n            action.unsubscribe();\n          }\n\n          throw error;\n        }\n      }\n    }]);\n  }(AsyncScheduler);\n\n  VirtualTimeScheduler.frameTimeFactor = 10;\n  return VirtualTimeScheduler;\n})();\nexport var VirtualAction = /*#__PURE__*/function (_AsyncAction) {\n  function VirtualAction(scheduler, work) {\n    var _this2;\n\n    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : scheduler.index += 1;\n\n    _classCallCheck(this, VirtualAction);\n\n    _this2 = _callSuper(this, VirtualAction, [scheduler, work]);\n    _this2.scheduler = scheduler;\n    _this2.work = work;\n    _this2.index = index;\n    _this2.active = true;\n    _this2.index = scheduler.index = index;\n    return _this2;\n  }\n\n  _inherits(VirtualAction, _AsyncAction);\n\n  return _createClass(VirtualAction, [{\n    key: \"schedule\",\n    value: function schedule(state) {\n      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (!this.id) {\n        return _superPropGet(VirtualAction, \"schedule\", this, 3)([state, delay]);\n      }\n\n      this.active = false;\n      var action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    }\n  }, {\n    key: \"requestAsyncId\",\n    value: function requestAsyncId(scheduler, id) {\n      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      this.delay = scheduler.frame + delay;\n      var actions = scheduler.actions;\n      actions.push(this);\n      actions.sort(VirtualAction.sortActions);\n      return true;\n    }\n  }, {\n    key: \"recycleAsyncId\",\n    value: function recycleAsyncId(scheduler, id) {\n      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      return undefined;\n    }\n  }, {\n    key: \"_execute\",\n    value: function _execute(state, delay) {\n      if (this.active === true) {\n        return _superPropGet(VirtualAction, \"_execute\", this, 3)([state, delay]);\n      }\n    }\n  }], [{\n    key: \"sortActions\",\n    value: function sortActions(a, b) {\n      if (a.delay === b.delay) {\n        if (a.index === b.index) {\n          return 0;\n        } else if (a.index > b.index) {\n          return 1;\n        } else {\n          return -1;\n        }\n      } else if (a.delay > b.delay) {\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n  }]);\n}(AsyncAction); //# sourceMappingURL=VirtualTimeScheduler.js.map","map":null,"metadata":{},"sourceType":"module"}